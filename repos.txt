===> base.go <===
package repository

import (
	"context"

	"github.com/jmoiron/sqlx"
	"github.com/stannisl/avito-test/pkg/db"
)

type BaseRepository struct {
	db        *sqlx.DB
	txManager db.TransactionManager
}

func (r *BaseRepository) GetTx(ctx context.Context) sqlx.ExtContext {
	if tx, ok := ctx.Value("tx").(*sqlx.Tx); ok {
		return tx
	}
	return r.db
}

func (r *BaseRepository) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error {
	return r.txManager.WithTransaction(ctx, fn)
}
===> team.go <===
package repository

import (
	"context"

	"github.com/jmoiron/sqlx"
	"github.com/stannisl/avito-test/internal/domain"
)

type TeamRepository interface {
	// CreateTeam создает новую команду
	CreateTeam(ctx context.Context, team domain.Team) error

	// GetTeam возвращает команду по имени
	GetTeam(ctx context.Context, name domain.TeamName) (*domain.Team, error)

	// TeamExists проверяет существование команды
	TeamExists(ctx context.Context, name domain.TeamName) (bool, error)
}

type teamRepository struct {
	db *sqlx.DB
}

func NewTeamRepository(db *sqlx.DB) TeamRepository {
	return &teamRepository{db: db}
}

func (t *teamRepository) CreateTeam(ctx context.Context, team domain.Team) error {
	query := `INSERT INTO teams (name) VALUES ($1)`
	tx, err := t.db.BeginTxx(ctx, nil)
	if err != nil {
		return err
	}

	_, err = tx.ExecContext(ctx, query, team.Name)
	if err != nil {
		tx.Rollback()
		return err
	}

	return tx.Commit()
}

func (t *teamRepository) GetTeam(ctx context.Context, name domain.TeamName) (*domain.Team, error) {
	query := `SELECT name FROM teams WHERE name = $1`
	var team domain.Team

	err := t.db.GetContext(ctx, &team, query, name)
	if err != nil {
		return nil, err
	}

	return &team, nil
}

func (t *teamRepository) TeamExists(ctx context.Context, name domain.TeamName) (bool, error) {
	query := `SELECT name FROM teams WHERE name = $1`
	var team domain.Team

	err := t.db.GetContext(ctx, &team, query, name)
	if err != nil {
		return false, err
	}
	return team.Name == name, nil
}
===> pull_request.go <===
package repository

import (
	"context"

	"github.com/jmoiron/sqlx"
	"github.com/stannisl/avito-test/internal/domain"
)

type PullRequestRepository interface {
	// Create создает новый PR
	Create(ctx context.Context, pr *domain.PullRequest) error

	// GetByID возвращает PR по ID
	GetByID(ctx context.Context, prID domain.PRID) (*domain.PullRequest, error)

	// Update обновляет PR
	Update(ctx context.Context, pr *domain.PullRequest) error

	// GetByReviewerID возвращает все PR, где пользователь назначен ревьювером
	GetByReviewerID(ctx context.Context, reviewerID domain.UserID) ([]domain.PullRequest, error)

	// Exists проверяет существование PR
	Exists(ctx context.Context, prID domain.PRID) (bool, error)
}

type pullRequestRepository struct {
	db *sqlx.DB
}

func NewPullRequestRepository(db *sqlx.DB) PullRequestRepository {
	return &pullRequestRepository{db: db}
}

func (p *pullRequestRepository) Create(ctx context.Context, pr *domain.PullRequest) error {
	query := `INSERT INTO pull_requests (id, name, author_id, merged_at) VALUES (:id, :name, :author_id, :merged_at)`

	tx, err := p.db.BeginTxx(ctx, nil)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	_, err = tx.NamedExecContext(ctx, query, pr)
	if err != nil {
		return err
	}

	if len(pr.AssignedReviewers) > 0 {
		query := `INSERT INTO pull_request_reviewers (pull_request_id, reviewer_id) VALUES ($1, $2)`

		for _, userID := range pr.AssignedReviewers {
			_, err := tx.ExecContext(ctx, query, pr.ID, userID)
			if err != nil {
				return err
			}
		}
	}

	return tx.Commit()
}

func (p *pullRequestRepository) GetByID(ctx context.Context, prID domain.PRID) (*domain.PullRequest, error) {
	query := `
		SELECT (id, name, author_id, status, need_more_reviewers, created_at, merged_at) 
		FROM pull_requests 
		WHERE id = $1
	`
	var pr domain.PullRequest
	err := p.db.GetContext(ctx, &pr, query, prID)
	if err != nil {
		return nil, err
	}

	getReviewers := `
		SELECT reviewer_id
		FROM pull_request_reviewers
		WHERE pull_request_id = $1
		ORDER BY reviewer_id
	`

	var reviewers []domain.UserID
	if err := p.db.SelectContext(ctx, &reviewers, getReviewers, prID); err != nil {
		return nil, err
	}

	pr.AssignedReviewers = reviewers

	return &pr, nil
}

func (p *pullRequestRepository) Update(ctx context.Context, pr *domain.PullRequest) error {
	query := `
		UPDATE pull_requests 
		SET status = :status,  merged_at = :merged_at, need_more_reviewers = :need_more_reviewers 
		WHERE id = :id
	`

	tx, err := p.db.BeginTxx(ctx, nil)
	if err != nil {
		return err
	}

	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	_, err = tx.NamedExecContext(ctx, query, pr)
	if err != nil {
		return err
	}

	delQuery := `DELETE FROM pull_request_reviewers WHERE pull_request_id = $1`
	if _, err = tx.ExecContext(ctx, delQuery, pr.ID); err != nil {
		return err
	}

	if len(pr.AssignedReviewers) > 0 {
		insertQuery := `INSERT INTO pull_request_reviewers (pull_request_id, reviewer_id) VALUES ($1, $2)`
		for _, r := range pr.AssignedReviewers {
			if _, err = tx.ExecContext(ctx, insertQuery, pr.ID, r); err != nil {
				return err
			}
		}
	}

	return tx.Commit()
}

func (p *pullRequestRepository) GetByReviewerID(
	ctx context.Context,
	reviewerID domain.UserID,
) ([]domain.PullRequest, error) {
	query := `SELECT * FROM pull_request_reviewers WHERE reviewer_id = $1`

	var prs []domain.PullRequest
	err := p.db.SelectContext(ctx, &prs, query, reviewerID)
	if err != nil {
		return nil, err
	}

	return prs, nil
}

func (p *pullRequestRepository) Exists(ctx context.Context, prID domain.PRID) (bool, error) {
	query := `SELECT * FROM pull_requests WHERE id = $1`
	var pr domain.PullRequest

	err := p.db.GetContext(ctx, &pr, query, prID)
	if err != nil {
		return false, err
	}

	return pr.ID == prID, nil
}
===> dependencies.go <===
package repository

type Dependencies struct {
	PullRequestRepository PullRequestRepository
	TeamRepository        TeamRepository
	UserRepository        UserRepository
}
===> user.go <===
package repository

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/jmoiron/sqlx"
	"github.com/stannisl/avito-test/internal/domain"
)

type UserRepository interface {
	// CreateOrUpdateUser создает или обновляет пользователя
	CreateOrUpdateUser(ctx context.Context, user *domain.User) error

	// GetUser возвращает пользователя по ID
	GetUser(ctx context.Context, userID domain.UserID) (*domain.User, error)

	// GetActiveUsersByTeamWithLimit возвращает активных пользователей команды (исключая указанного)
	GetActiveUsersByTeamWithLimit(
		ctx context.Context,
		teamName domain.TeamName,
		excludeUserID []domain.UserID,
		limit int,
	) ([]domain.User, error)

	// SetIsActive устанавливает флаг активности пользователя
	SetIsActive(ctx context.Context, userID domain.UserID, isActive bool) error

	// GetUsersByTeam возвращает всех пользователей команды
	GetUsersByTeam(ctx context.Context, teamName domain.TeamName) ([]domain.User, error)
}

type userRepository struct {
	conn *sqlx.DB
}

func NewUserRepository(conn *sqlx.DB) UserRepository {
	return &userRepository{
		conn: conn,
	}
}

func (u *userRepository) CreateOrUpdateUser(ctx context.Context, user *domain.User) error {
	query := `INSERT INTO users (id, username, team_name, is_active) VALUES (:id, :username, :team_name, :is_active)`

	tx, err := u.conn.BeginTxx(ctx, nil)
	if err != nil {
		errTr := tx.Rollback()
		if errTr != nil {
			return errTr
		}
		return err
	}

	if _, err = tx.NamedExecContext(ctx, query, user); err != nil {
		errTr := tx.Rollback()
		if errTr != nil {
			return errTr
		}
		return err
	}

	return tx.Commit()
}

func (u *userRepository) GetUser(ctx context.Context, userID domain.UserID) (*domain.User, error) {
	query := `SELECT (id, username, team_name, is_active) FROM users WHERE id = $1`

	var user domain.User

	if err := u.conn.Get(&user, query, userID); err != nil {
		return nil, err
	}

	return &user, nil
}

func (u *userRepository) GetActiveUsersByTeamWithLimit(
	ctx context.Context,
	teamName domain.TeamName,
	excludeUserID []domain.UserID,
	limit int,
) ([]domain.User, error) {
	rawQuery := `SELECT (id, username, team_name, is_active) FROM users WHERE team_name = $1 AND is_active = true AND`
	var (
		query string
		args  = []any{teamName}
	)

	usersVariables := make([]string, len(excludeUserID))
	for i, userID := range excludeUserID {
		usersVariables[i] = fmt.Sprintf("$%d", len(args)+1)
		args = append(args, userID)
	}

	usersExcluding := fmt.Sprintf(" id NOT IN (%s) ORDER BY random()", strings.Join(usersVariables, ", "))

	if limit >= 0 {
		query = rawQuery + usersExcluding + " LIMIT $3"
		args = append(args, limit)
	} else {
		query = rawQuery + usersExcluding
	}

	log.Println(query, args)

	var users []domain.User

	if err := u.conn.SelectContext(ctx, &users, query, args...); err != nil {
		return nil, err
	}

	return users, nil
}

func (u *userRepository) SetIsActive(ctx context.Context, userID domain.UserID, isActive bool) error {
	query := `UPDATE users SET is_active = $1 WHERE id = $2`

	tx, err := u.conn.BeginTxx(ctx, nil)
	if err != nil {
		tx.Rollback()
		return err
	}

	if _, err := tx.ExecContext(ctx, query, isActive, userID); err != nil {
		errTr := tx.Rollback()
		if errTr != nil {
			return errTr
		}
		return err
	}

	return tx.Commit()
}

func (u *userRepository) GetUsersByTeam(ctx context.Context, teamName domain.TeamName) ([]domain.User, error) {
	query := `SELECT (id, username, team_name, is_active) FROM users WHERE team_name = $1`
	var users []domain.User

	err := u.conn.SelectContext(ctx, &users, query, teamName)
	if err != nil {
		return nil, err
	}
	return users, nil
}
